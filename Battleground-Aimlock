--[[
    Roblox Script: Lock-On Nearest Player Button GUI (Notification UI, 1s Duration, Reliable Button Text)
    - Press the GUI button to rotate your HumanoidRootPart toward the nearest player.
    - Lock-on persists until button is pressed again, which temporarily ignores the last target for 3 seconds.
    - The UI is draggable, modern, and NOTIFICATIONS are used instead of a status label.
    - Notification duration is 1 second for all notifications.
    - Button text is always set reliably (no disappearing).
    - Fixes "camera stuck at skybox" by never attempting to rotate if the lock vector is too small.
    - Place this LocalScript in StarterGui or StarterPlayerScripts.
    - No NPC support (players only).
]]

--// SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")
local LocalPlayer = Players.LocalPlayer

--// GUI CREATION
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "LockOnGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local Frame = Instance.new("Frame")
Frame.Name = "LockOnFrame"
Frame.Size = UDim2.new(0, 270, 0, 80)
Frame.Position = UDim2.new(0.5, -135, 0.85, 0)
Frame.AnchorPoint = Vector2.new(0.5, 0)
Frame.BackgroundColor3 = Color3.fromRGB(32, 34, 40)
Frame.BackgroundTransparency = 0.04
Frame.BorderSizePixel = 0
Frame.Active = true
Frame.Parent = ScreenGui

local UICorner = Instance.new("UICorner")
UICorner.CornerRadius = UDim.new(0, 22)
UICorner.Parent = Frame

local UIStroke = Instance.new("UIStroke")
UIStroke.Thickness = 3
UIStroke.Color = Color3.fromRGB(0, 170, 255)
UIStroke.Transparency = 0.10
UIStroke.Parent = Frame

--// BUTTON
local LockButton = Instance.new("TextButton")
LockButton.Name = "LockOnButton"
LockButton.Size = UDim2.new(1, -44, 0, 40)
LockButton.Position = UDim2.new(0, 22, 0, 20)
LockButton.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
LockButton.TextColor3 = Color3.fromRGB(255, 255, 255)
LockButton.Text = "ðŸ”’ LOCK-ON"
LockButton.Font = Enum.Font.GothamBlack
LockButton.TextSize = 23
LockButton.AutoButtonColor = true
LockButton.ZIndex = 2
LockButton.Parent = Frame

local ButtonCorner = Instance.new("UICorner")
ButtonCorner.CornerRadius = UDim.new(0, 13)
ButtonCorner.Parent = LockButton

local ButtonStroke = Instance.new("UIStroke")
ButtonStroke.Thickness = 2
ButtonStroke.Color = Color3.fromRGB(0, 170, 255)
ButtonStroke.Transparency = 0.13
ButtonStroke.Parent = LockButton

--// BUTTON HOVER ANIMATION
LockButton.MouseEnter:Connect(function()
	TweenService:Create(LockButton, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(0, 220, 255)}):Play()
end)
LockButton.MouseLeave:Connect(function()
	TweenService:Create(LockButton, TweenInfo.new(0.18), {BackgroundColor3 = Color3.fromRGB(0, 170, 255)}):Play()
end)

--// VARIABLES
local locked = false
local ignorePlayer = nil
local ignoreUntil = 0
local lockTarget = nil

--// NOTIFICATION FUNCTION (1 second duration)
local function notify(title, text)
	StarterGui:SetCore("SendNotification", {
		Title = title or "Notice";
		Text = text or "";
		Duration = 1;
	})
end

--// FUNCTIONS

local function getDistance(pos1, pos2)
    return (pos1 - pos2).Magnitude
end

local function getNearestPlayer()
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return nil end
    local myPos = myChar.HumanoidRootPart.Position

    local nearest, minDist = nil, math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player ~= ignorePlayer then
            local char = player.Character
            if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChildOfClass("Humanoid") and char:FindFirstChildOfClass("Humanoid").Health > 0 then
                local dist = getDistance(myPos, char.HumanoidRootPart.Position)
                if dist < minDist then
                    minDist = dist
                    nearest = player
                end
            end
        end
    end
    return nearest
end

local function rotateToTarget(targetPlayer)
    local myChar = LocalPlayer.Character
    local targetChar = targetPlayer and targetPlayer.Character
    if not (myChar and targetChar) then return end
    local hrp = myChar:FindFirstChild("HumanoidRootPart")
    local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
    if not (hrp and targetHRP) then return end

    local lookVec = (targetHRP.Position - hrp.Position)
    local flatLook = Vector3.new(lookVec.X, 0, lookVec.Z)
    if flatLook.Magnitude < 0.1 or not flatLook.Unit then return end -- Don't rotate if target is too close or vector is invalid

    -- Defensive: in rare bug cases, flatLook.Unit may error if flatLook is zero vector
    local success, unit = pcall(function() return flatLook.Unit end)
    if not success or not unit then return end

    hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + unit)
end

--// MAIN LOCK-ON LOOP
RunService.RenderStepped:Connect(function()
    if locked and lockTarget and lockTarget.Character and lockTarget.Character:FindFirstChild("HumanoidRootPart") then
        rotateToTarget(lockTarget)
    end
end)

--// BUTTON HANDLER
LockButton.MouseButton1Click:Connect(function()
    -- Always set button text immediately to prevent disappearing
    if locked then
        LockButton.Text = "LOCK-ON"
        LockButton.TextColor3 = Color3.fromRGB(255,255,255)
        TweenService:Create(LockButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(0, 170, 255)}):Play()
        ignorePlayer = lockTarget
        ignoreUntil = tick() + 3
        locked = false
        lockTarget = nil
        notify("Lock-Off", "Ignoring last player for 3 seconds...")
        task.spawn(function()
            local remaining = ignoreUntil - tick()
            if remaining > 0 then task.wait(remaining) end
            ignorePlayer = nil
        end)
    else
        local nearest = getNearestPlayer()
        if nearest then
            LockButton.Text = "UNLOCK"
            LockButton.TextColor3 = Color3.fromRGB(0, 170, 255)
            TweenService:Create(LockButton, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(255,255,255)}):Play()
            lockTarget = nearest
            locked = true
            notify("Locked-On!", "Now locking on to: " .. (nearest.DisplayName or nearest.Name))
        else
            LockButton.Text = "ðŸ”’ LOCK-ON" -- Make absolutely sure it doesn't disappear
            LockButton.TextColor3 = Color3.fromRGB(255,255,255)
            TweenService:Create(LockButton, TweenInfo.new(0.13), {BackgroundColor3 = Color3.fromRGB(255, 80, 80)}):Play()
            TweenService:Create(LockButton, TweenInfo.new(0.5), {BackgroundColor3 = Color3.fromRGB(0, 170, 255)}):Play()
            notify("No Players Found", "No nearby players to lock onto!")
        end
    end
end)

LocalPlayer.CharacterAdded:Connect(function()
    locked = false
    lockTarget = nil
    ignorePlayer = nil
    LockButton.Text = "ðŸ”’ LOCK-ON"
    LockButton.TextColor3 = Color3.fromRGB(255,255,255)
    LockButton.BackgroundColor3 = Color3.fromRGB(0,170,255)
    notify("Ready", "Ready to Lock-On!")
end)

--// DRAGGABLE UI (mouse & touch)
local UserInputService = game:GetService("UserInputService")
local dragging = false
local dragStart, startPos

local function updateDrag(input)
	local delta = input.Position - dragStart
	Frame.Position = UDim2.new(
		startPos.X.Scale,
		startPos.X.Offset + delta.X,
		startPos.Y.Scale,
		startPos.Y.Offset + delta.Y
	)
end

Frame.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = Frame.Position
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

Frame.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if dragging then
			updateDrag(input)
		end
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
		updateDrag(input)
	end
end)

--// END
