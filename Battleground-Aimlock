--[[
    Roblox Script: Lock-On Nearest Player Button GUI (Retro Roblox UI + SFX)
    - Press the GUI button or press V to rotate your HumanoidRootPart toward the nearest player.
    - Lock-on persists until button is pressed again or V is pressed again, which temporarily ignores the last target for 3 seconds.
    - If the locked player dies or leaves, lock-off automatically with a notification and reason.
    - The UI is draggable, styled with a retro/old Roblox look, and plays SFX on press or V key toggle.
    - Uses notifications for feedback (1 second duration).
    - Place this LocalScript in StarterGui or StarterPlayerScripts.
    - No NPC support (players only).
    - SFX uses Roblox's classic UI sound.
]]

--// SERVICES
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local StarterGui = game:GetService("StarterGui")
local TweenService = game:GetService("TweenService")
local SoundService = game:GetService("SoundService")
local LocalPlayer = Players.LocalPlayer

--// RETRO SFX SETUP (uses built-in Roblox sound asset)
local retroSFX = Instance.new("Sound")
retroSFX.SoundId = "rbxassetid://12221967" -- Old Roblox button click SFX
retroSFX.Volume = 0.65
retroSFX.Name = "RetroLockSFX"
retroSFX.Parent = SoundService

--// GUI CREATION
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "LockOnGui"
ScreenGui.ResetOnSpawn = false
ScreenGui.IgnoreGuiInset = true
ScreenGui.Parent = LocalPlayer:WaitForChild("PlayerGui")

local Frame = Instance.new("Frame")
Frame.Name = "LockOnFrame"
Frame.Size = UDim2.new(0, 220, 0, 60)
Frame.Position = UDim2.new(0.5, -110, 0.88, 0)
Frame.AnchorPoint = Vector2.new(0.5, 0)
Frame.BackgroundColor3 = Color3.fromRGB(163, 162, 165) -- Classic Roblox gray
Frame.BorderColor3 = Color3.fromRGB(27, 42, 53) -- Retro border
Frame.BorderSizePixel = 2
Frame.Active = true
Frame.Parent = ScreenGui

local TitleBar = Instance.new("TextLabel")
TitleBar.Name = "TitleBar"
TitleBar.Size = UDim2.new(1, 0, 0, 20)
TitleBar.Position = UDim2.new(0, 0, 0, 0)
TitleBar.BackgroundColor3 = Color3.fromRGB(49, 49, 49)
TitleBar.BorderColor3 = Color3.fromRGB(27, 42, 53)
TitleBar.BorderSizePixel = 1
TitleBar.Text = "Lock-On     [V]"
TitleBar.Font = Enum.Font.Legacy
TitleBar.TextColor3 = Color3.fromRGB(255, 255, 255)
TitleBar.TextSize = 16
TitleBar.TextXAlignment = Enum.TextXAlignment.Left
TitleBar.TextYAlignment = Enum.TextYAlignment.Center
TitleBar.ClipsDescendants = true
TitleBar.Parent = Frame

local LockButton = Instance.new("TextButton")
LockButton.Name = "LockOnButton"
LockButton.Size = UDim2.new(1, -14, 0, 28)
LockButton.Position = UDim2.new(0, 7, 0, 26)
LockButton.BackgroundColor3 = Color3.fromRGB(190, 190, 190)
LockButton.BorderColor3 = Color3.fromRGB(27, 42, 53)
LockButton.BorderSizePixel = 2
LockButton.TextColor3 = Color3.fromRGB(33, 33, 33)
LockButton.Text = "Lock-On"
LockButton.Font = Enum.Font.Legacy
LockButton.TextSize = 18
LockButton.AutoButtonColor = false
LockButton.ZIndex = 2
LockButton.Parent = Frame

--// RETRO EFFECT (scanlines overlay)
local Scanlines = Instance.new("ImageLabel")
Scanlines.Name = "Scanlines"
Scanlines.BackgroundTransparency = 1
Scanlines.Image = "rbxassetid://14897047154" -- Free scanline overlay, replaceable
Scanlines.Size = UDim2.new(1, 0, 1, 0)
Scanlines.Position = UDim2.new(0,0,0,0)
Scanlines.ImageTransparency = 0.57
Scanlines.Parent = Frame
Scanlines.ZIndex = 100

--// RETRO BUTTON ANIMATION (pressed color flicker)
local function retroButtonFlicker()
	LockButton.BackgroundColor3 = Color3.fromRGB(180, 140, 60)
	wait(0.08)
	LockButton.BackgroundColor3 = Color3.fromRGB(190, 190, 190)
end

--// VARIABLES
local locked = false
local ignorePlayer = nil
local ignoreUntil = 0
local lockTarget = nil
local targetDeathConn = nil
local targetRemovalConn = nil

--// NOTIFICATION FUNCTION (1 second duration)
local function notify(title, text)
	StarterGui:SetCore("SendNotification", {
		Title = title or "Notice";
		Text = text or "";
		Duration = 1;
	})
end

--// CLEANUP OLD CONNECTIONS
local function disconnectTargetEvents()
	if targetDeathConn then
		targetDeathConn:Disconnect()
		targetDeathConn = nil
	end
	if targetRemovalConn then
		targetRemovalConn:Disconnect()
		targetRemovalConn = nil
	end
end

--// AUTO UNLOCK IF TARGET DIES OR LEAVES
local function watchTarget(targetPlayer)
	disconnectTargetEvents()
	if not targetPlayer then return end
	-- Watch for death
	local humanoid = targetPlayer.Character and targetPlayer.Character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		targetDeathConn = humanoid.Died:Connect(function()
			locked = false
			LockButton.Text = "Lock-On"
			LockButton.TextColor3 = Color3.fromRGB(33,33,33)
			LockButton.BackgroundColor3 = Color3.fromRGB(190, 190, 190)
			notify("Lock-Off", "Target died!")
			lockTarget = nil
			disconnectTargetEvents()
		end)
	end
	-- Watch for leaving game
	targetRemovalConn = targetPlayer.AncestryChanged:Connect(function()
		if not targetPlayer:IsDescendantOf(Players) then
			if locked then
				locked = false
				LockButton.Text = "Lock-On"
				LockButton.TextColor3 = Color3.fromRGB(33,33,33)
				LockButton.BackgroundColor3 = Color3.fromRGB(190, 190, 190)
				notify("Lock-Off", "Target left the game!")
				lockTarget = nil
				disconnectTargetEvents()
			end
		end
	end)
end

--// FUNCTIONS

local function getDistance(pos1, pos2)
    return (pos1 - pos2).Magnitude
end

local function getNearestPlayer()
    local myChar = LocalPlayer.Character
    if not myChar or not myChar:FindFirstChild("HumanoidRootPart") then return nil end
    local myPos = myChar.HumanoidRootPart.Position

    local nearest, minDist = nil, math.huge
    for _, player in ipairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player ~= ignorePlayer then
            local char = player.Character
            if char and char:FindFirstChild("HumanoidRootPart") and char:FindFirstChildOfClass("Humanoid") and char:FindFirstChildOfClass("Humanoid").Health > 0 then
                local dist = getDistance(myPos, char.HumanoidRootPart.Position)
                if dist < minDist then
                    minDist = dist
                    nearest = player
                end
            end
        end
    end
    return nearest
end

local function rotateToTarget(targetPlayer)
    local myChar = LocalPlayer.Character
    local targetChar = targetPlayer and targetPlayer.Character
    if not (myChar and targetChar) then return end
    local hrp = myChar:FindFirstChild("HumanoidRootPart")
    local targetHRP = targetChar:FindFirstChild("HumanoidRootPart")
    if not (hrp and targetHRP) then return end

    local lookVec = (targetHRP.Position - hrp.Position)
    local flatLook = Vector3.new(lookVec.X, 0, lookVec.Z)
    if flatLook.Magnitude < 0.1 or not flatLook.Unit then return end -- Don't rotate if target is too close or vector is invalid

    local success, unit = pcall(function() return flatLook.Unit end)
    if not success or not unit then return end

    hrp.CFrame = CFrame.new(hrp.Position, hrp.Position + unit)
end

--// MAIN LOCK-ON LOOP
RunService.RenderStepped:Connect(function()
    if locked and lockTarget and lockTarget.Character and lockTarget.Character:FindFirstChild("HumanoidRootPart") then
        rotateToTarget(lockTarget)
    end
end)

--// LOCK/UNLOCK LOGIC (shared by button and V key)
local function doToggleLock()
	-- Play retro SFX and visual flicker
	pcall(function() retroSFX:Play() end)
	retroButtonFlicker()

    if locked then
        LockButton.Text = "Lock-On"
        LockButton.TextColor3 = Color3.fromRGB(33,33,33)
        LockButton.BackgroundColor3 = Color3.fromRGB(190, 190, 190)
        ignorePlayer = lockTarget
        ignoreUntil = tick() + 3
        locked = false
        disconnectTargetEvents()
        notify("Lock-Off", "Ignoring last player for 3 seconds...")
        local prevTarget = lockTarget
        lockTarget = nil
        task.spawn(function()
            local remaining = ignoreUntil - tick()
            if remaining > 0 then task.wait(remaining) end
            if ignorePlayer == prevTarget then
                ignorePlayer = nil
            end
        end)
    else
        local nearest = getNearestPlayer()
        if nearest then
            LockButton.Text = "Unlock"
            LockButton.TextColor3 = Color3.fromRGB(33,33,33)
            LockButton.BackgroundColor3 = Color3.fromRGB(190, 190, 190)
            lockTarget = nearest
            locked = true
            watchTarget(nearest)
            notify("Locked-On!", "Now locking on to: " .. (nearest.DisplayName or nearest.Name))
        else
            LockButton.Text = "Lock-On"
            LockButton.TextColor3 = Color3.fromRGB(33,33,33)
            LockButton.BackgroundColor3 = Color3.fromRGB(190, 190, 190)
            notify("No Players Found", "No nearby players to lock onto!")
        end
    end
end

--// BUTTON HANDLER
LockButton.MouseButton1Click:Connect(doToggleLock)

--// KEYBOARD HANDLER (V KEY)
local UserInputService = game:GetService("UserInputService")
UserInputService.InputBegan:Connect(function(input, processed)
    if processed then return end
    if input.KeyCode == Enum.KeyCode.V then
        doToggleLock()
    end
end)

LocalPlayer.CharacterAdded:Connect(function()
    locked = false
    lockTarget = nil
    ignorePlayer = nil
    LockButton.Text = "Lock-On"
    LockButton.TextColor3 = Color3.fromRGB(33,33,33)
    LockButton.BackgroundColor3 = Color3.fromRGB(190, 190, 190)
    disconnectTargetEvents()
    notify("Ready", "Ready to Lock-On!")
end)

--// DRAGGABLE UI (mouse & touch, via TitleBar only for retro feel)
local dragging = false
local dragStart, startPos

TitleBar.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch then
		dragging = true
		dragStart = input.Position
		startPos = Frame.Position
		input.Changed:Connect(function()
			if input.UserInputState == Enum.UserInputState.End then
				dragging = false
			end
		end)
	end
end)

TitleBar.InputChanged:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch then
		if dragging then
			local delta = input.Position - dragStart
			Frame.Position = UDim2.new(
				startPos.X.Scale,
				startPos.X.Offset + delta.X,
				startPos.Y.Scale,
				startPos.Y.Offset + delta.Y
			)
		end
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if dragging and (input.UserInputType == Enum.UserInputType.MouseMovement or input.UserInputType == Enum.UserInputType.Touch) then
		local delta = input.Position - dragStart
		Frame.Position = UDim2.new(
			startPos.X.Scale,
			startPos.X.Offset + delta.X,
			startPos.Y.Scale,
			startPos.Y.Offset + delta.Y
		)
	end
end)

--// END
